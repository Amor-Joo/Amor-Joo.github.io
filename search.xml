<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux系统的vim/vi使用</title>
      <link href="/2020/02/28/linux-vim-use/"/>
      <url>/2020/02/28/linux-vim-use/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><div class="note info">            <p>转载来自：<a href="https://www.cnblogs.com/pythonlearing/p/9749338.html" target="_blank" rel="noopener">Linux之Vim编辑器</a></p>          </div><h2 id="vi-vim的介绍"><a href="#vi-vim的介绍" class="headerlink" title="vi/vim的介绍"></a>vi/vim的介绍</h2><ul><li>vi编辑器是所有Unix及Linux系统下标准的编辑器，他就相当于windows系统中的记事本一样，它的强大不逊色于任何最新的文本编辑器。它是我们使用Linux系统不能缺少的工具。</li><li>由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，学会它后，您将在Linux的世界里畅行无阻。</li><li>vim 具有<strong>程序编辑</strong>的能力，可以以字体颜色辨别语法的正确性，方便程序设计；<u>因为程序简单，编辑速度相当快速。</u></li><li><strong>vim可以当作vi的升级版本</strong>，它可以用多种颜色的方式来显示一些特殊的信息。</li><li>vim会依据文件扩展名或者是文件内的开头信息， 判断该文件的内容而自动的执行该程序的语法判断式，再以颜色来显示程序代码与一般信息。</li><li>vim里面加入了很多额外的功能，例如<b style="color: yellow;background-color: black;">支持正则表达式的搜索</b>、<b style="color: yellow;background-color: black;">多文件编辑</b>、<b style="color: yellow;background-color: black;">块复制</b>等等。 </li></ul><h2 id="vi的使用"><a href="#vi的使用" class="headerlink" title="vi的使用"></a>vi的使用</h2><h3 id="vi的三种状态"><a href="#vi的三种状态" class="headerlink" title="vi的三种状态"></a>vi的三种状态</h3><p class="indent_p">基本上vi可以分为三种状态，分别是<b style="color: blue;background-color: yellow;">一般模式</b>、<b style="color: blue;background-color: yellow;">编辑模式</b>和<b style="color: blue;background-color: yellow;">命令行模式</b>，各模式的功能区分如下：</p><p><a href="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-28_LVU/modes.png" data-fancybox="group" data-caption="三种模式" class="fancybox"><img alt="三种模式" title="三种模式" data-src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-28_LVU/modes.png" src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/img/loading_calf.gif" class="lazyload"></a></p><ul><li><p><strong>一般模式</strong>(默认)：<br>以vi打开一个文件就直接进入一般模式了(这是默认的模式)。在这个模式中，你可以使用上下左右按键来移动光标，你可以<b style="color: blue;background-color: yellow;">使用删除字符或删除整行来处理文件内容</b>，也可以使用<b style="color: green;background-color: orange;">复制、粘贴</b>来处理你的文件数据。</p></li><li><p><strong>编辑模式</strong>：<br>在一般模式中可以进行删除、复制、粘贴等的操作，但是却无法编辑文件的内容，只有当到你按下 <kbd>i</kbd>, <kbd>I</kbd>, <kbd>o</kbd>, <kbd>O</kbd>, <kbd>a</kbd>, <kbd>A</kbd>, <kbd>r</kbd>, <kbd>R</kbd> 等任何一个字母之后才会进入编辑模式。这时候屏幕的左下方会出现【INSERT 或 REPLACE】的字样，此时才可以进行<b style="color: blue;background-color: yellow;">编辑</b>。而如果要回到一般模式时，则必须要按下 <kbd>Esc</kbd> 才可退出编辑模式。</p></li><li><p><strong>命令行模式</strong>：<br>输入 <kbd>:</kbd>, <kbd>/</kbd>, <kbd>?</kbd> 三个中的任何一个，就可以将光标移动到最底下那一行。在这个模式中，可以提供<b style="color: blue;background-color: yellow;">查找、读取、存盘、替换字符、离开vi、显示行号</b>等的操作</p></li></ul><h3 id="一般模式可用的按键说明"><a href="#一般模式可用的按键说明" class="headerlink" title="一般模式可用的按键说明"></a>一般模式可用的按键说明</h3><h4 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h4><p><kbd>h</kbd>、<kbd>j</kbd>、<kbd>k</kbd>、<kbd>l</kbd>，分别控制光标左、下、上、右移一格<br>按<kbd>ctrl</kbd>+<kbd>b</kbd>屏幕往“后”移动一页(back)<br>按<kbd>ctrl</kbd>+<kbd>f</kbd>屏幕往“前”移动一页(front)<br><kbd>数字n</kbd>+<kbd>space</kbd>光标向右移动n个字符<br><kbd>shift</kbd>+<kbd>Home</kbd>移动到这一行的<b style="color: yellow;background-color: black;">最前面字符</b>处<br><kbd>shift</kbd>+<kbd>End</kbd>移动到这一行的<b style="color: yellow;background-color: black;">最后面字符</b>处<br><kbd>w</kbd>光标跳到<b style="color: yellow;background-color: black;">下个单词的开头</b><br><kbd>e</kbd>光标跳到<b style="color: yellow;background-color: black;">下个单词的字尾</b><br><kbd>shift</kbd>+<kbd>h</kbd>光标移动到<b style="color: blue;background-color: yellow;">这个屏幕</b>的<b style="color: yellow;background-color: black;">最上方那一行</b>的第一个字符<br><kbd>shift</kbd>+<kbd>m</kbd>光标移动到<b style="color: blue;background-color: yellow;">这个屏幕</b>的<b style="color: yellow;background-color: black;">中间那一行</b>的第一个字符<br><kbd>shift</kbd>+<kbd>l</kbd>光标移动到<b style="color: blue;background-color: yellow;">这个屏幕</b>的<b style="color: yellow;background-color: black;">最下方那一行</b>的第一个字符<br><kbd>shift</kbd>+<kbd>g</kbd>移动到这个文件的最后一行<br><kbd>数字n</kbd>+<kbd>shift</kbd>+<kbd>g</kbd>移动到这个文件的第n行(可配合<code>:set nu</code>)<br><kbd>gg</kbd>移动到这个文件的第一行，相当于<kbd>1</kbd>+<kbd>shift</kbd>+<kbd>g</kbd><br><kbd>数字n</kbd>+<kbd>Enter</kbd>光标向下移动n行</p><h4 id="查找与替换"><a href="#查找与替换" class="headerlink" title="查找与替换"></a>查找与替换</h4><p><kbd>/word</kbd> $\boldsymbol{\Rightarrow}$ 向光标向下寻找一个名称为word的字符串<br><kbd>?word</kbd> $\boldsymbol{\Rightarrow}$ 向光标向上寻找一个名称为word的字符串</p><p><kbd>:noh</kbd> $\boldsymbol{\Rightarrow}$ <b style="color: blue;background-color: yellow;">取消查找后的高亮显示</b></p><p><kbd>n</kbd> $\boldsymbol{\Rightarrow}$ 代表重复前一个查找的动作<br><kbd>N</kbd> $\boldsymbol{\Rightarrow}$ 与n刚好相反，为<b style="color: yellow;background-color: red;">反向</b>进行前一个查找动作</p><p><kbd>:n1,n2s/word1/word2/g</kbd> $\boldsymbol{\Rightarrow}$ n1与n2为数字，在第n1与n2行之间查找word1这个字符串，并将该字符串替换为word2<br><kbd>:1,$s/word1/word2/g</kbd> $\boldsymbol{\Rightarrow}$ 从第一行到最后一行查找word1字符串，并将该字符串替换为word2<br><kbd>:1,$s/word1/word2/gc</kbd> $\boldsymbol{\Rightarrow}$ 从第一行到最后一行查找word1字符串，并将该字符串替换为word2，且在替换前提示用户确认是否进行替换</p><h4 id="块选择"><a href="#块选择" class="headerlink" title="块选择"></a>块选择</h4><p><kbd>v</kbd> 字符选择，会将光标经过的地方反白选择<br><kbd>shift</kbd>+<kbd>v</kbd> 行选择，会将光标经过的行反白选择<br><kbd>ctrl</kbd>+<kbd>v</kbd> 块选择，可以用长方形的方式选择资料 （提取竖列）<br><kbd>y</kbd> 将反白的地方复制<br><kbd>d</kbd> 将反白的地方删除</p><h4 id="删除、复制与粘贴"><a href="#删除、复制与粘贴" class="headerlink" title="删除、复制与粘贴"></a>删除、复制与粘贴</h4><ul><li>通常搭配 <strong>块选择</strong> 来操作</li></ul><p><kbd>x</kbd> 为向后删除一个字符 (相当于<kbd>del</kbd>键)<br><kbd>X</kbd> 为向前删除一个字符(相当于<kbd>backspace</kbd>键)<br><kbd>数字n</kbd>+<kbd>x</kbd> 连续向后删除n个字符</p><p><kbd>dd</kbd> 删除光标所在行<br><kbd>ndd</kbd> 删除光标所在的向下n行</p><p><kbd>d1G</kbd> 删除光标<b style="color: blue;background-color: yellow;">所在行</b>，到<b style="color: yellow;background-color: black;">第一行</b>的所有数据<br><kbd>dG</kbd> 删除光标<b style="color: blue;background-color: yellow;">所在行</b>，到<b style="color: yellow;background-color: black;">最后一行</b>的所有数据</p><p><kbd>d0</kbd> 删除光标<b style="color: blue;background-color: yellow;">所在的那个字符</b>，到<strong>该行</strong>的<b style="color: yellow;background-color: black;">最前一个字符</b><br><kbd>d$</kbd> 删除光标<b style="color: blue;background-color: yellow;">所在的那个字符</b>，到<strong>该行</strong>的<b style="color: yellow;background-color: black;">最后一个字符</b></p><p><kbd>yy</kbd> 复制光标所在的那一行<br><kbd>nyy</kbd> 复制光标所在的向下n行</p><p><kbd>y1G</kbd> 复制光标<b style="color: blue;background-color: yellow;">所在行</b>，到<b style="color: yellow;background-color: black;">第一行</b>的所有数据<br><kbd>yG</kbd> 复制光标<b style="color: blue;background-color: yellow;">所在行</b>，到<b style="color: yellow;background-color: black;">最后一行</b>的所有数据</p><p><kbd>y0</kbd> 复制光标<b style="color: blue;background-color: yellow;">所在的那个字符</b>，到<b style="color: yellow;background-color: black;">该行行首</b>的所有数据<br><kbd>y$</kbd> 复制光标<b style="color: blue;background-color: yellow;">所在的那个字符</b>，到<b style="color: yellow;background-color: black;">该行行尾</b>的所有数据</p><p><kbd>p</kbd> 将已复制的数据在<b style="color: yellow;background-color: black;">光标下一行</b>粘贴上<br><kbd>ctrl</kbd>+<kbd>p</kbd> 将已复制的数据在<b style="color: yellow;background-color: black;">光标上一行</b>粘贴上</p><p><kbd>u</kbd> 恢复前一个操作<br><kbd>ctrl</kbd>+<kbd>r</kbd> 重做上一个操作</p><p><kbd>.</kbd> 是重复前一个操作</p><h3 id="一般模式切换到编辑模式"><a href="#一般模式切换到编辑模式" class="headerlink" title="一般模式切换到编辑模式"></a>一般模式切换到编辑模式</h3><ul><li><p>【i, I】 进入编辑模式：<br><kbd>i</kbd> $\boldsymbol{\Rightarrow}$ 从目前光标所在处插入<br><kbd>shift</kbd>+<kbd>i</kbd> $\boldsymbol{\Rightarrow}$ 在目前所在行的第一个非空格符处开始插入</p></li><li><p>【a, A】 进入编辑模式(Insert mode)：<br><kbd>a</kbd> $\boldsymbol{\Rightarrow}$ 从目前光标所在的下一个字符处开始插入<br><kbd>shift</kbd>+<kbd>a</kbd> $\boldsymbol{\Rightarrow}$ 从光标所在行的最后一个字符处开始插入</p></li><li><p>【o, O】 进入编辑模式：<br><kbd>o</kbd> $\boldsymbol{\Rightarrow}$ 在目前光标所在的下一行处插入新的一行<br><kbd>shift</kbd>+<kbd>o</kbd> $\boldsymbol{\Rightarrow}$ 在目前光标所在处的上一行插入新的一行</p></li><li><p>【r, R】 进入取代模式：<br><kbd>r</kbd> $\boldsymbol{\Rightarrow}$ 只会取代光标所在的那一个字符一次<br><kbd>shift</kbd>+<kbd>r</kbd> $\boldsymbol{\Rightarrow}$ 会一直取代光标所在的文字，直到按下 ESC 为止</p></li></ul><h3 id="一般模式切换到命令行模式"><a href="#一般模式切换到命令行模式" class="headerlink" title="一般模式切换到命令行模式"></a>一般模式切换到命令行模式</h3><p><kbd>:w</kbd> 保存编辑的内容<br><kbd>:w!</kbd> 强制写入该文件，但跟你对该文件的权限有关<br><kbd>:q</kbd> 离开vi<br><kbd>:q!</kbd> 不想保存修改，强制离开<br><kbd>:wq</kbd> 保存后离开<br><kbd>:x</kbd> 保存后离开<br><kbd>ZZ</kbd> 若文件没有更动，则不保存离开；若文件已经被更改过，则保存后离开</p><p><kbd>:w filename</kbd> 将编辑的数据保存成另一个文件（类似另存）<br><kbd>:r filename</kbd> 在编辑的数据中，读入另一个文件的数据。即将<strong>filename</strong>这个文件的内容加到光标所在行后面。</p><p><kbd>:n1,n2 w filename</kbd> 将n1到n2的内容保存成<strong>filename</strong>这个文件。<br><kbd>:! command</kbd> 暂时离开vi，到命令行模式下执行<strong>command</strong>的显示结果！例如 <kbd>:! ls /home</kbd>即可在vi当中查看/home目录底下的文件信息！</p><p><kbd>:set nu</kbd> 显示行号<br><kbd>:set nonu</kbd> 与<kbd>:set nu</kbd>相反，为取消行</p><h2 id="vim的功能"><a href="#vim的功能" class="headerlink" title="vim的功能"></a>vim的功能</h2><p class="indent_p">其实，目前大部分的Linux发行版本都以vim取代了vi。为什么要用vim呢？因为vim具有<b style="color: blue;background-color: yellow;">颜色显示</b>的功能，并且还<b style="color: blue;background-color: yellow;">支持许多的程序语法(syntax)和相应的提示信息</b></p><p class="indent_p">查看自己的VI是不是被VIM代替，可以在终端输入<b><code>alias</code></b>这个命令，来检查输出结果是不是有<code>alias vi='vim'</code>这一行</p><p><a href="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-28_LVU/alias.png" data-fancybox="group" data-caption="查看vim/vi" class="fancybox"><img alt="查看vim/vi" title="查看vim/vi" data-src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-28_LVU/alias.png" src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/img/loading_calf.gif" class="lazyload"></a></p><h3 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h3><p class="indent_p">大家在使用vim的时候，可能会碰到你需要复制一个文件中的某段到另外一个文件中，而vim不能够在关闭的时候，把这段保留住。或者是用其它的方法复制。</p><p><kbd>vim file1 file2</kbd></p><p><kbd>:n</kbd> 编辑下一个文件<br><kbd>:N</kbd> 编辑上一个文件<br><kbd>:files</kbd> 列出目前这个vim编辑的所有文件</p><h3 id="多窗口功能"><a href="#多窗口功能" class="headerlink" title="多窗口功能"></a>多窗口功能</h3><p class="indent_p">有两个需要对照着看的文件</p><ul><li><p><kbd>:sp filename</kbd> 开启一个新窗口，如果有加<strong>filename</strong>，表示在新窗口开启一个新文件，否则表示两个窗口为同一个文件内容(同步显示)。</p></li><li><p><kbd>ctrl</kbd>+<kbd>w</kbd>+<kbd>j</kbd> 或者 <kbd>ctrl</kbd>+<kbd>w</kbd>+<kbd>↓</kbd> 按键<br>$\boldsymbol{\Rightarrow}$ 先按下<kbd>ctrl</kbd>不放，再按下<kbd>w</kbd>后放开所有的按键，然后再按下<kbd>j</kbd>(或<kbd>↓</kbd>)，则光标可移动到下方的窗口。</p></li><li><p><kbd>ctrl</kbd>+<kbd>w</kbd>+<kbd>k</kbd> 或者 <kbd>ctrl</kbd>+<kbd>w</kbd>+<kbd>↑</kbd> 按键<br>$\boldsymbol{\Rightarrow}$ 同上，不过光标移动到上面的窗口</p></li></ul><h3 id="vim记录"><a href="#vim记录" class="headerlink" title="vim记录"></a>vim记录</h3><blockquote><p><code>~/.viminfo</code> $\boldsymbol{\Leftarrow}$ vim会主动的将你曾经做过的行为记录下来</p></blockquote><p><a href="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-28_LVU/viminfo.png" data-fancybox="group" data-caption=".viminfo文件" class="fancybox"><img alt=".viminfo文件" title=".viminfo文件" data-src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-28_LVU/viminfo.png" src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/img/loading_calf.gif" class="lazyload"></a></p><p class="indent_p">如果不想要记录动作的功能，可以把文件<code>~/.viminfo</code>删除。</p><h3 id="vim环境设定"><a href="#vim环境设定" class="headerlink" title="vim环境设定"></a>vim环境设定</h3><ul><li>vim的环境设定参数有很多，如果你想要知道目前的设定值，可以在一般模式时输入<kbd>:set all</kbd>来查阅</li><li>常用的一些简单的设定值：<br><kbd>:set all</kbd> “显示目前所有的环境参数设定值<br><kbd>:set hlsearch</kbd> “高亮度反白(高亮度搜寻)<br><kbd>:set nohlsearch</kbd> “取消高亮度反白(高亮度搜寻)<br><kbd>:set backspace=2</kbd> “在编辑的时候可随时用退格键删除 （０、１的时候，只针对刚输入的字符有效）<br><kbd>:set autoindent</kbd> “自动缩排<br><kbd>:set noautoindent</kbd> “取消自动缩排<br><kbd>:set ruler</kbd> “可显示最后一行的状态<br><kbd>:set showmode</kbd> “左下角那一行的状态<br><kbd>:set nu</kbd> “显示行号<br><kbd>:set nonu</kbd> “取消行号<br><kbd>:set bg=dark</kbd> “显示不同的底色色调<br><kbd>:syntax on</kbd> “进行语法检验，颜色显示<br><kbd>:syntax off</kbd> “关闭语法检验</li><li>配置当前用户的vim环境<br>文件 $\boldsymbol{\Rightarrow}$ <code>~/.vimrc</code></li><li>配置整体的vim环境<br>文件 $\boldsymbol{\Rightarrow}$ <code>/etc/vimrc</code></li></ul><blockquote><p>例如：</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set hlsearch "高亮度反白</span><br><span class="line">set backspace=2 "可随时用退格键删除</span><br><span class="line">set autoindent "自动缩排</span><br><span class="line">set ruler "可显示最后一行的状态</span><br><span class="line">set showmode "左下角那一行的状态</span><br><span class="line">set nu "可以在每一行的最前面显示行号</span><br><span class="line">set bg=dark "显示不同的底色色调</span><br><span class="line">syntax on "进行语法检验，颜色显示</span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-28_LVU/vimrc.png" data-fancybox="group" data-caption=".vimrc文件" class="fancybox"><img alt=".vimrc文件" title=".vimrc文件" data-src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-28_LVU/vimrc.png" src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/img/loading_calf.gif" class="lazyload"></a></p><ul><li>文件的双引号<kbd>“</kbd>表示的是注释</li><li>文件中每一行前面加不加<kbd>:</kbd>效果都是一样的</li></ul><style type="text/css">    .indent_p {        text-indent: 2em;    }    .indent_2_p {        text-indent: 4em;    }    /* <p class="indent_p"> */    kbd {        display: inline-block;        padding: 3px 5px;        font: 11px Consolas,"Liberation Mono",Menlo,Courier,monospace;        line-height: 10px;        color: #555;        vertical-align: middle;        background-color: #fcfcfc;        border: 1px solid #ccc;        border-bottom-color: #bbb;        border-radius: 3px;        box-shadow: inset 0 -1px 0 #bbb;    }</style></body></html>]]></content>
      
      
      <categories>
          
          <category> Linux学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH远程连接VirtualBox中的LinuxOS</title>
      <link href="/2020/02/27/ssh-connect-linux/"/>
      <url>/2020/02/27/ssh-connect-linux/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><div class="note default">            <p><b style="color: green">学Linux，首先要戒掉图形界面，多用终端!</b></p>          </div><div class="note info">            <div class="table-container"><table><thead><tr><th style="text-align:center">操作系统</th><th style="text-align:center">虚拟机</th><th style="text-align:center">虚拟机操作系统</th></tr></thead><tbody><tr><td style="text-align:center"><b class="bold_Code"><code>Windows 10</code></b></td><td style="text-align:center"><b class="bold_Code"><code>Virtual Box</code></b></td><td style="text-align:center"><b class="bold_Code"><code>CentOS(无图形界面)</code></b></td></tr></tbody></table></div>          </div><h1 id="ssh连接虚拟机的LinuxOS"><a href="#ssh连接虚拟机的LinuxOS" class="headerlink" title="ssh连接虚拟机的LinuxOS"></a>ssh连接虚拟机的LinuxOS</h1><h2 id="步骤1：设置虚拟机的网络"><a href="#步骤1：设置虚拟机的网络" class="headerlink" title="步骤1：设置虚拟机的网络"></a>步骤1：设置虚拟机的网络</h2><div class="note info">            <p>参考：<a href="https://www.douban.com/group/topic/15558388/" target="_blank" rel="noopener">VirtualBox虚拟机网络设置(四种方式)</a></p>          </div><ol><li>设置虚拟机的网络为“<strong>网络地址转换NET</strong>”<ul><li>虚拟主机并不真实存在于网络中，访问网络的所有数据都是由主机提供的<br><a href="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-27_SCL/p_1.png" data-fancybox="group" data-caption="选择网络地址转换NET" class="fancybox"><img alt="选择网络地址转换NET" title="选择网络地址转换NET" data-src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-27_SCL/p_1.png" src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/img/loading_calf.gif" class="lazyload"></a></li><li>设置端口转发<br><a href="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-27_SCL/p_2.png" data-fancybox="group" data-caption="设置端口转发" class="fancybox"><img alt="设置端口转发" title="设置端口转发" data-src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-27_SCL/p_2.png" src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/img/loading_calf.gif" class="lazyload"></a></li></ul></li><li>设置网络为“<strong>桥接模式</strong>”<ul><li>桥接模式分配给虚拟机一个网络中独立的IP地址，所以可以用该IP地址进行SSH连接<br><a href="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-27_SCL/p_桥接模式.png" data-fancybox="group" data-caption="桥接模式" class="fancybox"><img alt="桥接模式" title="桥接模式" data-src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-27_SCL/p_桥接模式.png" src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/img/loading_calf.gif" class="lazyload"></a></li><li>使用<code>ifconfig</code>查看linux的IP地址：<br><a href="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-27_SCL/p_查看IP地址.png" data-fancybox="group" data-caption="查看IP地址" class="fancybox"><img alt="查看IP地址" title="查看IP地址" data-src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-27_SCL/p_查看IP地址.png" src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/img/loading_calf.gif" class="lazyload"></a></li></ul></li></ol><blockquote><p><b style="background-color: yellow;color: black">桥接模式</b>与<b style="background-color: yellow;color: black">网络地址转换</b>两者选其一即可</p></blockquote><h2 id="步骤2：Linux中安装ssh"><a href="#步骤2：Linux中安装ssh" class="headerlink" title="步骤2：Linux中安装ssh"></a>步骤2：Linux中安装ssh</h2><ul><li>输入命令 <code>rpm -qa | grep ssh</code> ,出现下面的框内内容，则已安装<br><a href="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-27_SCL/p_3.png" data-fancybox="group" data-caption="检查SSH是否安装" class="fancybox"><img alt="检查SSH是否安装" title="检查SSH是否安装" data-src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-27_SCL/p_3.png" src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/img/loading_calf.gif" class="lazyload"></a></li><li>或者<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh localhost </span><br><span class="line"><span class="comment"># 使用该命令后，如果已经安装，会提示你是否接收服务器发给你的公钥，并让你输入yes/no，此时输入yes，这样才能对你发给服务器的信息进行加密</span></span><br></pre></td></tr></tbody></table></figure></div></li><li>若未安装ssh<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果你用的是redhat，fedora，centos等系列linux发行版，那么敲入以下命令：</span></span><br><span class="line">sudo yum install ssh</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">sudo yum install openssh-server（由osc网友 火耳提供）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你使用的是debian，ubuntu，linux mint等系列的linux发行版，那么敲入以下命令：</span></span><br><span class="line">sudo apt-get install ssh</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">sudo apt-get install openssh-server（由osc网友 火耳提供）</span><br><span class="line"><span class="comment"># 然后按照提示安装</span></span><br></pre></td></tr></tbody></table></figure></div></li></ul><h2 id="步骤3：开启SSH服务"><a href="#步骤3：开启SSH服务" class="headerlink" title="步骤3：开启SSH服务"></a>步骤3：开启SSH服务</h2><ul><li>开启ssh服务<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd start</span><br></pre></td></tr></tbody></table></figure></div></li><li>查看是否开启服务<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e | grep sshd</span><br></pre></td></tr></tbody></table></figure></div></li><li>卸载服务<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果你用的是redhat，fedora，centos等系列linux发行版，那么敲入以下命令：</span></span><br><span class="line">yum remove sshd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你使用的是debian，ubuntu，linux mint等系列的linux发行版，那么敲入以下命令：</span></span><br><span class="line">sudo apt-get –purge remove sshd</span><br></pre></td></tr></tbody></table></figure></div></li></ul><h2 id="步骤4：进行SSH连接"><a href="#步骤4：进行SSH连接" class="headerlink" title="步骤4：进行SSH连接"></a>步骤4：进行SSH连接</h2><h3 id="在shell中输入"><a href="#在shell中输入" class="headerlink" title="在shell中输入"></a>在shell中输入</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh -p [主机端口号] [登录名]@[IP地址]</span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line"><span class="comment"># ssh -p 2223 amor-joo@localhost（localhost也可以改为127.0.0.1）</span></span><br><span class="line"><span class="comment"># ssh amor-joo@192.168.2.147</span></span><br></pre></td></tr></tbody></table></figure></div><ol><li>网络地址转换：<br><a href="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-27_SCL/p_4.png" data-fancybox="group" data-caption="Shell中SSH连接_NET" class="fancybox"><img alt="Shell中SSH连接_NET" title="Shell中SSH连接_NET" data-src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-27_SCL/p_4.png" src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/img/loading_calf.gif" class="lazyload"></a></li><li>桥接模式：<br><a href="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-27_SCL/p_shell-ssh-桥接模式.png" data-fancybox="group" data-caption="Shell中SSH连接_桥接模式" class="fancybox"><img alt="Shell中SSH连接_桥接模式" title="Shell中SSH连接_桥接模式" data-src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-27_SCL/p_shell-ssh-桥接模式.png" src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/img/loading_calf.gif" class="lazyload"></a></li></ol><h3 id="或者使用putty"><a href="#或者使用putty" class="headerlink" title="或者使用putty"></a>或者使用putty</h3><p><a href="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-27_SCL/p_5.png" data-fancybox="group" data-caption="使用Putty进行SSH连接" class="fancybox"><img alt="使用Putty进行SSH连接" title="使用Putty进行SSH连接" data-src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-27_SCL/p_5.png" src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/img/loading_calf.gif" class="lazyload"></a></p><!-- 这是一个HTML注释 --><style type="text/css">    .indent_p {        text-indent: 2em;    }    .indent_2_p {        text-indent: 4em;    }    /* <p class="indent_p"> */    .bold_Code {        color: #2cd058;        text-decoration: underline;        cursor: pointer;    }    .bold_Code *{        color: #2440d2 !important;    }</style></body></html>]]></content>
      
      
      <categories>
          
          <category> Linux学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML类图的介绍</title>
      <link href="/2020/02/10/UML-Class-Diagram/"/>
      <url>/2020/02/10/UML-Class-Diagram/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="UML的介绍"><a href="#UML的介绍" class="headerlink" title="UML的介绍"></a>UML的介绍</h1><p class="indent_p">UML —— Unified Modeling Language(统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果</p><p class="indent_p">UML是一个通用的标准建模语言，可以对任何具有静态结构和动态行为的系统进行建模，而且适用于系统开发的不同阶段，从需求规格描述直至系统完成后的测试和维护。</p><p class="indent_p">截止UML2.0一共有13种图形（UML1.5定义了9种，2.0增加了4种）。分别是：<u>用例图</u>、<u>类图</u>、<u>对象图</u>、<u>状态图</u>、<u>活动图</u>、<u>顺序图</u>、<u>协作图</u>、<u>构件图</u>、<u>部署图</u>9种，<u>包图</u>、<u>组合结构图</u>、<u>交互概览图</u>3种</p><h1 id="主要模型"><a href="#主要模型" class="headerlink" title="主要模型"></a>主要模型</h1><p class="indent_p">在UML系统开发中有三个主要的模型：</p><ol><li>功能模型<br>从用户的角度展示系统的功能，包括 <u><strong>用例图</strong></u>  </li><li>对象模型<br>采用对象、属性、操作、关联等概念，展示系统的结构和基础，包括 <u><strong>类图</strong></u>、<u><strong>对象图</strong></u>、<u><strong>包图</strong></u></li><li>动态模型<br>展现系统的内部行为。包括 <u><strong>序列图</strong></u>、<u><strong>活动图</strong></u>、<u><strong>状态图</strong></u></li></ol><h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><div class="note info">            <p>生成 UML 的工具 —— IDEA中的插件 <strong>PlantUML</strong>，<a class="toc-link" href="#INNER-TOOLS" target="_self">其他工具</a></p>          </div><h2 id="类图基础属性"><a href="#类图基础属性" class="headerlink" title="类图基础属性"></a>类图基础属性</h2><p class="indent_p">方法、成员变量的权限表示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">-</td><td>private</td></tr><tr><td style="text-align:center">+</td><td>public</td></tr><tr><td style="text-align:center">#</td><td>protected</td></tr><tr><td style="text-align:center">~</td><td>default(包私有)</td></tr><tr><td style="text-align:center">_</td><td>static(静态)</td></tr><tr><td style="text-align:center">斜体</td><td>abstract(抽象)</td></tr></tbody></table></div><p><a href="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-10_UCD/1_1.png" data-fancybox="group" data-caption="类图示例" class="fancybox"><img alt="类图示例" title="类图示例" data-src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-10_UCD/1_1.png" src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/img/loading_calf.gif" class="lazyload"></a></p><h2 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系"></a>类与类之间的关系</h2><div class="note info">            <p><strong>参考:</strong> <a href="https://www.cnblogs.com/h2zZhou/p/6256725.html" target="_blank" rel="noopener" title="UML类图符号 各种关系说明以及举例">https://www.cnblogs.com/h2zZhou/p/6256725.html</a></p>          </div><p class="indent_p">UML中描述对象和类之间相互关系的方式包括：<a class="toc-link" href="#INNER-dependency" target="_self" title="虚线箭头">依赖</a>，<a class="toc-link" href="#INNER-association" target="_self" title="实线箭头">关联</a>，<a class="toc-link" href="#INNER-aggregation" target="_self" title="空心菱形头的实线">聚合</a>，<a class="toc-link" href="#INNER-composition" target="_self" title="实心菱形头的实线">组合</a>，<a class="toc-link" href="#INNER-generalization" target="_self" title="空心三角箭头的实线">泛化</a>，<a class="toc-link" href="#INNER-realization" target="_self" title="空心三角箭头的实线">实现</a>等。</p><p class="indent_p">而关系的强弱：<b>组合</b> > <b>聚合</b> > <b>关联</b> > <b>依赖</b></p><div class="table-container"><table><thead><tr><th style="text-align:center">关系类型</th><th>具体内容</th><th style="text-align:center">栗子</th></tr></thead><tbody><tr><td style="text-align:center">聚合</td><td>表明对象之间的整体与部分关系的关联</td><td style="text-align:center">has a</td></tr><tr><td style="text-align:center">组合</td><td>表明整体与部分之间有相同生命周期关系的聚合</td><td style="text-align:center">contains a</td></tr><tr><td style="text-align:center">依赖</td><td>描述了对象之间的调用关系</td><td style="text-align:center">方法中的调用</td></tr><tr><td style="text-align:center">关联</td><td>描述了对象之间的结构关系</td><td style="text-align:center">作为成员变量</td></tr></tbody></table></div><p><a href="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-10_UCD/1_2.png" data-fancybox="group" data-caption="关系图标" class="fancybox"><img alt="关系图标" title="关系图标" data-src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-10_UCD/1_2.png" src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/img/loading_calf.gif" class="lazyload"></a>  </p><h3 id="依赖-——-虚线箭头"><a href="#依赖-——-虚线箭头" class="headerlink" title="依赖 —— 虚线箭头"></a><span id="INNER-dependency">依赖 —— 虚线箭头</span></h3><p>依赖（Dependency）：</p><p class="indent_p"><b>元素A的变化会影响元素B，但反之不成立，那么B和A的关系是依赖关系，B依赖A；</b> 类属关系和实现关系在语义上讲也是依赖关系，但由于其有更特殊的用途，所以被单独描述。uml中用<b>带箭头的虚线表示</b>，箭头<u>指向被依赖元素。</u></p><blockquote><p>注意：  </p><ol><li><strong>依赖关系也是类与类之间的联结</strong></li><li>依赖总是<u>单向</u>的（要避免 <s style="color: RED"><strong>双向依赖</strong></s> 。一般来说，不应该存在双向依赖）</li><li>依赖关系在 <strong>Java</strong> 或 <strong>C++</strong> 语言中体现为 <u>局部变量</u>、<u>方法的参数</u> 或者 <u>对静态方法的调用</u></li></ol></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">class Person {</span><br><span class="line">    +buy(Car car): void</span><br><span class="line">}</span><br><span class="line">class Car</span><br><span class="line"></span><br><span class="line">Car <.. Person</span><br><span class="line"></span><br><span class="line">note as N1</span><br><span class="line">    Car对象的变化会影响到Person对象,</span><br><span class="line">    所以 <b><color: red>Person 依赖于 Car</color:></b></span><b><br><span class="line">    <i>注意：</i></span><i><br><span class="line">    1. <u><b><color: green>依赖总是单向的</color:></b></u>，不应该存在 <s>双向依赖</s></span><br><span class="line">    2. 依赖关系体现在 <u><b>局部变量</b></u>、<u><b>方法参数</b></u>、<u><b>静态方法的调用</b></u></span><br><span class="line">end note</span><br><span class="line"></span><br><span class="line">@enduml</span><br></i></b></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-10_UCD/test_1.png" data-fancybox="group" data-caption="依赖关系" class="fancybox"><img alt="依赖关系" title="依赖关系" data-src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-10_UCD/test_1.png" src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/img/loading_calf.gif" class="lazyload"></a>  </p><h3 id="关联-——-实线箭头"><a href="#关联-——-实线箭头" class="headerlink" title="关联 —— 实线箭头"></a><span id="INNER-association">关联 —— 实线箭头</span></h3><p>关联（Association）：</p><p class="indent_p">元素间的结构化关系，是一种 <u><b>弱关系</b></u> ，被关联的元素间通常可以被独立的考虑。uml中用实线表示Association关系，箭头指向被依赖元素。</p><blockquote><p>注意：</p><ol><li>关联关系是类与类之间的联结，它 <b style="color: green">使一个类知道另一个类的属性和方法</b></li><li><u><strong>关联可以是双向的，也可以是单向的（还有自身关联）</strong></u>。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头</li><li>在 Java 或 c++ 中，关联关系是通过 <strong>使用成员变量</strong> 来实现的</li></ol></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">class 多啦A梦 {</span><br><span class="line">    -tools: List<tool></tool></span><br><span class="line">}</span><br><span class="line">class Tool</span><br><span class="line"></span><br><span class="line">多啦A梦 "1" --> "*" Tool : "关联"</span><br><span class="line"></span><br><span class="line">note as N1</span><br><span class="line">    关联关系，作为成员变量</span><br><span class="line">end note</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-10_UCD/test_2.png" data-fancybox="group" data-caption="关联关系" class="fancybox"><img alt="关联关系" title="关联关系" data-src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-10_UCD/test_2.png" src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/img/loading_calf.gif" class="lazyload"></a>  </p><h3 id="聚合-——-空心菱形头的实线"><a href="#聚合-——-空心菱形头的实线" class="headerlink" title="聚合 —— 空心菱形头的实线"></a><span id="INNER-aggregation">聚合 —— 空心菱形头的实线</span></h3><p>聚合（Aggregation）：</p><p class="indent_p">关联关系的一种特例，表示部分和整体（<b style="color: #3592c4">整体 has a 部分</b>）的关系。uml中用<b>带空心菱形头的实线表示</b>，<u>菱形头指向整体。</u></p><blockquote><p>注意：</p><ol><li>聚合关系是关联关系的一种，是 <u><strong>强的关联关系</strong></u></li><li><u>聚合是整体和部分之间的关系，例如汽车由引擎、轮胎以及其它零件组成</u></li><li>聚合关系也是通过 <strong>成员变量</strong> 来实现的。但是，关联关系所涉及的两个类处在同一个层次上，而聚合关系中，两个类处于不同的层次上，一个代表整体，一个代表部分</li><li>关联与聚合仅仅从 Java 或 C++ 语法上是无法分辨的，<strong>必须考察所涉及的类之间的逻辑关系</strong></li></ol></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">class 汽车 {</span><br><span class="line">    -轮胎[4]: 轮胎</span><br><span class="line">    -发动机: 发动机</span><br><span class="line">}</span><br><span class="line">class 轮胎</span><br><span class="line">class 发动机</span><br><span class="line"></span><br><span class="line">汽车 o--> 轮胎 : "聚合"</span><br><span class="line">汽车 o--> 发动机 : "聚合"</span><br><span class="line"></span><br><span class="line">note as N1</span><br><span class="line">    聚合关系 —— 空心的菱形，菱形指向整体</span><br><span class="line">    <b><color: blue>(整体被破坏，个体不一定随之被破坏)</color:></b></span><b><br><span class="line">    <b><color: green>(聚合的个体可能被多个整体所共享)</color:></b></span><b><br><span class="line">    has a</span><br><span class="line">end note</span><br><span class="line"></span><br><span class="line">@enduml</span><br></b></b></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-10_UCD/test_3.png" data-fancybox="group" data-caption="聚合关系" class="fancybox"><img alt="聚合关系" title="聚合关系" data-src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-10_UCD/test_3.png" src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/img/loading_calf.gif" class="lazyload"></a>  </p><h3 id="组合-——-实心菱形头的实线"><a href="#组合-——-实心菱形头的实线" class="headerlink" title="组合 —— 实心菱形头的实线"></a><span id="INNER-composition">组合 —— 实心菱形头的实线<p span></p></span></h3><p>组合（Composition）：</p><p class="indent_p">组合是聚合关系的变种，表示元素间更强的组合关系(<b style="color: #3592c4">整体 contains a 部分</b>)。如果是组合关系，<u><b>如果整体被破坏则个体一定会被破坏</b></u>，而聚合的个体则可能是被多个整体所共享的，不一定会随着某个整体的破坏而被破坏。uml中<b>用带实心菱形头的实线</b>表示Composition关系，<u>菱形头指向整体</u>。</p><blockquote><p>注意：</p><ol><li>组合关系是关联关系的一种，是比聚合关系还要强的关系</li><li><b style="color: RED">它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期</b></li></ol></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">class Person {</span><br><span class="line">    -eyes[2]: Eye</span><br><span class="line">    -mouse: Mouse</span><br><span class="line">}</span><br><span class="line">class Mouse</span><br><span class="line">class Eye</span><br><span class="line"></span><br><span class="line">Person *--> Mouse : "组合"</span><br><span class="line">Person *--> Eye : "组合"</span><br><span class="line"></span><br><span class="line">note as N1</span><br><span class="line">    组合关系 —— 实心的菱形，菱形指向整体</span><br><span class="line">    <b><color: blue>(整体被破坏，个体一定被破坏)</color:></b></span><br><span class="line">    contains a</span><br><span class="line">end note</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-10_UCD/test_4.png" data-fancybox="group" data-caption="组合关系" class="fancybox"><img alt="组合关系" title="组合关系" data-src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-10_UCD/test_4.png" src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/img/loading_calf.gif" class="lazyload"></a>  </p><h3 id="一般化关系-泛化和实现"><a href="#一般化关系-泛化和实现" class="headerlink" title="一般化关系(泛化和实现)"></a>一般化关系(泛化和实现)</h3><p class="indent_p">表示<b>类与类之间的继承关系</b>，<b>接口与接口之间的继承关系</b>，或<b>类对接口的实现关系</b>。一般化关系是<u>子类指向父类的，或从实现接口的类指向被实现的接口，与继承或实现的方向相反</u>。</p><h4 id="泛化-——-空心三角箭头的实线"><a href="#泛化-——-空心三角箭头的实线" class="headerlink" title="泛化 —— 空心三角箭头的实线"></a><span id="INNER-generalization">泛化 —— 空心三角箭头的实线</span></h4><p class="indent_p">泛化（Generalization）：通常所说的 <b>继承</b>（特殊个体 is kind of 一般个体）关系，不必多解释了。uml中用<u>带空心三角箭头的实线表示</u>，<b style="color: red">箭头指向一般个体。</b></p><blockquote><p>注意：</p><ol><li>带空心三角箭头的实线表示</li><li>泛化表示一个更泛化的元素和一个更具体的元素之间的关系。泛化是用于对继承进行建模的UML元素。在Java中，用 <strong>extends</strong> 关键字来直接表示这种关系</li><li>泛化关系表示<u>类与类之间的继承关系，接口与接口之间的继承关系</u></li></ol></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">abstract class Vehicle {</span><br><span class="line">    -color: String</span><br><span class="line">    -weight: double</span><br><span class="line">    +{abstract} run(): void</span><br><span class="line">}</span><br><span class="line">class Sports_Car</span><br><span class="line">class Boat</span><br><span class="line"></span><br><span class="line">Vehicle <|-- Sports_Car : "继承"</span><br><span class="line">Vehicle <|-- Boat : "继承"</span><br><span class="line"></span><br><span class="line">note as N1</span><br><span class="line">    泛化(继承)关系</span><br><span class="line">     —— <b><color: blue>空心三角箭头的实线</color:></b>，箭头指向<b>父类或父接口</b></span><b><br><span class="line">    B is a kind of A</span><br><span class="line">end note</span><br><span class="line"></span><br><span class="line">@enduml</span><br></b></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-10_UCD/test_5.png" data-fancybox="group" data-caption="泛化关系" class="fancybox"><img alt="泛化关系" title="泛化关系" data-src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-10_UCD/test_5.png" src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/img/loading_calf.gif" class="lazyload"></a>  </p><h4 id="实现-——-空心三角箭头的虚线"><a href="#实现-——-空心三角箭头的虚线" class="headerlink" title="实现 —— 空心三角箭头的虚线"></a><span id="INNER-realization">实现 —— 空心三角箭头的虚线</span></h4><p class="indent_p">实现（Realization）：元素A定义一个约定，元素B实现这个约定，则B和A的关系是Realize，B realize A。这个关系最常用于接口。uml中<u>用空心三角箭头和虚线表示</u>，<b style="color: red">箭头指向定义约定的元素。</b></p><blockquote><p>实现关系指定两个实体之间的一个合同。换言之，<strong>一个实体定义一个合同，而另一个实体保证履行该合同。</strong> 对Java应用程序进行建模时，实现关系可直接用implements关键字来表示。</p></blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">interface IMath {</span><br><span class="line">    +{abstract} calculate(): void</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">IMath <|.. Person : "实现"</span><br><span class="line"></span><br><span class="line">note as N1</span><br><span class="line">    实现关系</span><br><span class="line">     —— <b><color: blue>空心三角箭头的虚线</color:></b>，箭头指向<b>实现的接口</b></span><b><br><span class="line">    B realize A</span><br><span class="line">end note</span><br><span class="line"></span><br><span class="line">@enduml</span><br></b></pre></td></tr></tbody></table></figure></div><p><a href="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-10_UCD/test_6.png" data-fancybox="group" data-caption="实现关系" class="fancybox"><img alt="实现关系" title="实现关系" data-src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/images/blog_imgs/20-02-10_UCD/test_6.png" src="https://cdn.jsdelivr.net/gh/amor-joo/amor-joo.github.io@master/img/loading_calf.gif" class="lazyload"></a>  </p><h2 id="UML类图工具"><a href="#UML类图工具" class="headerlink" title="UML类图工具"></a><span id="INNER-TOOLS">UML类图工具</span></h2><ol><li>建模软件 —— <a href="https://blog.csdn.net/huihui1094667985/article/details/79882629" target="_blank" rel="noopener" title="5分钟装好Rational Rose">Rational Rose</a></li><li>IDEA中的插件 —— <a href="https://blog.csdn.net/learneraiqi/article/details/53436423" target="_blank" rel="noopener" title="intellid idea安装plantUML插件以及错误解决">PlantUML</a> (本笔记使用)<br>—> <a href="https://plantuml.com/zh/" target="_blank" rel="noopener" title="开源工具，使用简单的文字描述画UML图">plantUML的使用语法</a></li><li>Eclipse中的插件 —— <a href="https://blog.csdn.net/long66666666/article/details/78337596" target="_blank" rel="noopener" title="Eclipse UML小工具AmaterasUML的配置和使用">AmaterasUML</a></li><li>在线作图网址：<a href="https://www.processon.com/" target="_blank" rel="noopener" title="免费在线作图、实时协作">ProcessOn</a></li></ol><p class="indent_p" style="text-align: center;color: gray;background-color: gray">我是不会告诉你新型冠状病毒的战役期间ProcessOn有团队版60天试用的！</p><style type="text/css">    .indent_p {        text-indent: 2em;    }    /* <p class="indent_p"> */</style></body></html>]]></content>
      
      
      <categories>
          
          <category> 编程知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML类图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本博客的介绍说明</title>
      <link href="/2020/01/25/2020-1-25-Introduction-of-blog/"/>
      <url>/2020/01/25/2020-1-25-Introduction-of-blog/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><div class="note success">            <p>博客主题 - <a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><code>hexo-theme-butterfly</code></a></p>          </div><div class="note info">            <p>这里并不介绍详细的主题配置、环境搭建，详细信息请见 <a href="https://jerryc.me/posts/21cfbf15/#%E5%BF%AB%E9%80%9F%E9%96%8B%E5%A7%8B" target="_blank" rel="noopener"><strong>jerryC</strong></a></p>          </div><h1 id="博客介绍"><a href="#博客介绍" class="headerlink" title="博客介绍"></a>博客介绍</h1><p class="indent_p">该博客网站是在 Github 下的使用 hexo 做成的静态博客网站，所使用的主题是 <b>Butterfly</b></p><p>而具体的配置方法请见 <a href="https://jerryc.me/posts/21cfbf15/#%E5%BF%AB%E9%80%9F%E9%96%8B%E5%A7%8B" target="_blank" rel="noopener"><strong>jerryC</strong></a></p><h2 id="已配置的内容"><a href="#已配置的内容" class="headerlink" title="已配置的内容"></a>已配置的内容</h2><ol><li>评论系统 - <a href="https://valine.js.org" target="_blank" rel="noopener" title="无后端评论系统">Valine</a></li><li>搜索 - local search / Algolia Search(它也能搜索，但是发现搜索到的内容的链接点不进去)<br>… …</li></ol><h2 id="配置过程中遇到的问题"><a href="#配置过程中遇到的问题" class="headerlink" title="配置过程中遇到的问题"></a>配置过程中遇到的问题</h2><h3 id="发现加载资源-特别是图片-很慢"><a href="#发现加载资源-特别是图片-很慢" class="headerlink" title="发现加载资源(特别是图片)很慢"></a>发现加载资源(特别是图片)很慢</h3><p class="indent_p">开始，我是放到图床上的，但是发现太麻烦了，在网上找了找，发现CDN加速更好使，就用的是CDN加速来加载项目里的资源。</p><p class="indent_p">CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p><p class="indent_p">放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。</p><blockquote><p>jsDelivr + Github的使用方法：<code>https://cdn.jsdelivr.net/gh/[user]/[repository]@[branch/version]/...</code><br>（user - Github用户名）<br>（repository - 仓库名）<br>（branch - 分支 或者 version - 发布的版本号）  </p></blockquote><style type="text/css">    .indent_p {        text-indent: 2em;    }    .indent_2_p {        text-indent: 4em;    }    /* <p class="indent_p"> */</style></body></html>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客介绍说明 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序的耦合</title>
      <link href="/2020/01/22/2020-1-22-Program-Coupling/"/>
      <url>/2020/01/22/2020-1-22-Program-Coupling/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script></head><body><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p class="indent_p">耦合性，也叫耦合度，是对模块间关联程序的度量。耦合的强弱取决于模块间结构和复杂性、调用模块的方式以及通过界面传递数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差（减低耦合性，可以提高其独立性）。</p><h2 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h2><p class="indent_p">在软件工程中，耦合指的就是对象之间的依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件的耦合最小、软件设计中通常用耦合度和内聚度作为衡量模块独立程度的标准。划分模块的一个准则就是 <b><u>高内聚低耦合</u></b> 。</p><blockquote><p class="indent_p">耦合包括两个方面：（Java中）</p><p class="indent_2_p">1. <u>类之间的耦合</u></p><p class="indent_2_p">2. <u>方法之间的耦合</u></p></blockquote><h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><p class="indent_p">解耦是指降低程序间的依赖关系。</p><p class="indent_p">而我们在实际的开发中，应该做到： <u><b>编译期不依赖，运行时依赖</b></u>。</p><p class="indent_p">所以，</p><blockquote><p class="indent_p">解耦的思路是：</p><p class="indent_2_p">第一步 - 使用 <b>反射</b> 来创建对象，而避免使用new关键字</p><p class="indent_2_p">第二步 - 通过 <b>读取配置文件</b> ，来获取要创建的对象的全限定类名</p></blockquote><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="编写JDBC的工程代码来分析程序的耦合"><a href="#编写JDBC的工程代码来分析程序的耦合" class="headerlink" title="编写JDBC的工程代码来分析程序的耦合"></a>编写JDBC的工程代码来分析程序的耦合</h2><p class="indent_p">下面是一种JDBC操作的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcDemo1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.注册驱动</span></span><br><span class="line">        DriverManager.registerDriver(<span class="keyword">new</span> com.mysql.jdbc.Driver());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建连接</span></span><br><span class="line">        Connection connection = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/ssm_spring"</span>,<span class="string">"root"</span>,<span class="string">"root"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.获取操作数据库的预处理对象</span></span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(<span class="string">"select * from account"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.执行SQL，得到结果集</span></span><br><span class="line">        ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.遍历结果集</span></span><br><span class="line">        <span class="keyword">while</span>(resultSet.next()){</span><br><span class="line">            System.out.println(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.释放资源</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        preparedStatement.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p class="indent_p">在注册驱动这一步骤当中，代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.注册驱动</span></span><br><span class="line">DriverManager.registerDriver(<span class="keyword">new</span> com.mysql.jdbc.Driver());</span><br></pre></td></tr></tbody></table></figure></div><p>当程序的库依赖没有这个驱动类时，该程序将<strong>无法正常编译</strong>，所以应当使用：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.注册驱动</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br></pre></td></tr></tbody></table></figure></div><p>这样在同样没有这个驱动类时，程序只是<strong>出现异常</strong>。</p><p class="indent_p">这样做就降低了程序间的依赖关系，实现了解耦。</p><p class="indent_p">不过呢，最好还是用配置文件的方式，从中读取驱动的名字，然后再加载驱动，这样就更能降低依赖关系，使代码更容易维护！</p><p class="indent_p">所以，标准的JDBC操作的步骤应该为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1.导入库文件</span></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBC</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>{</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement psmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 2.加载数据库驱动</span></span><br><span class="line">            Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>).newInstance();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3.创建连接</span></span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/mybatis"</span>,<span class="string">"root"</span>,<span class="string">"root"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3.获取操作数据库的预处理对象</span></span><br><span class="line">            psmt = connection.prepareStatement(<span class="string">"select * from account"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4.执行SQL，得到结果集</span></span><br><span class="line">            ResultSet rs = preparedStatement.executeQuery();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 5.遍历结果集</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next()) { </span><br><span class="line">                System.out.println(rs.getString(<span class="string">"name"</span>)); </span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            rs.close();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span>(conn != <span class="keyword">null</span>)</span><br><span class="line">                    conn.close();</span><br><span class="line">                <span class="keyword">if</span>(psmt != <span class="keyword">null</span>)</span><br><span class="line">                    psmt.close();</span><br><span class="line">            } <span class="keyword">catch</span>(Exception ex) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><style type="text/css">    .indent_p {        text-indent: 2em;    }    .indent_2_p {        text-indent: 4em;    }    /* <p class="indent_p"> */</style></body></html>]]></content>
      
      
      <categories>
          
          <category> Mybatis学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
            <tag> 程序耦合 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
